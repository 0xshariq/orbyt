/**
 * Engine Logger
 * 
 * Provides structured logging for the Orbyt Engine using ecosystem-core utilities.
 * Supports multiple output formats and log levels with proper filtering.
 * 
 * Features:
 * - Severity-based log level filtering using LogLevelSeverity
 * - Multiple output formats (pretty, text, json, structured)
 * - Color support with ANSI codes
 * - Engine-generated timestamps (consistent across CLI, API, web dashboards)
 * - Context and error tracking
 * - Performance measurement with automatic severity adjustment
 * - Efficient level comparison using numeric severity
 * 
 * Timestamps are generated by the engine to ensure consistency across:
 * - CLI output
 * - API responses
 * - Web dashboard logs
 * - Monitoring systems
 * - Audit trails
 * 
 * @module core
 */

import {
  LogLevel,
  LogLevelSeverity,
  formatLog,
  createLogEntry,
  shouldLog,
  formatTimestamp,
  type LogEntry,
  type LogFormatOptions,
} from '@dev-ecosystem/core';

/**
 * Re-export formatTimestamp for external use
 * Allows other parts of the system to format timestamps consistently
 */
export { formatTimestamp };

/**
 * Engine-specific log format type
 */
export type EngineLogFormat = 'pretty' | 'text' | 'json' | 'structured';

/**
 * Engine logger configuration
 */
export interface EngineLoggerConfig {
  /** Minimum log level to output */
  level: LogLevel;
  /** Output format */
  format?: EngineLogFormat;
  /** Enable colors in output */
  colors?: boolean;
  /** Include timestamps */
  timestamp?: boolean;
  /** Source identifier */
  source?: string;
}

/**
 * Engine Logger
 * 
 * Wraps ecosystem-core logging utilities with engine-specific configuration.
 */
export class EngineLogger {
  private config: Required<EngineLoggerConfig>;
  private formatOptions: LogFormatOptions;

  constructor(config: EngineLoggerConfig) {
    this.config = {
      level: config.level,
      format: config.format || 'text',
      colors: config.colors ?? true,
      timestamp: config.timestamp ?? true,
      source: config.source || 'Orbyt',
    };

    this.formatOptions = {
      format: this.config.format,
      colors: this.config.colors,
      timestamp: this.config.timestamp,
      includeSource: true,
    };
  }

  /**
   * Log a debug message
   */
  debug(message: string, context?: Record<string, unknown>): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  /**
   * Log an info message
   */
  info(message: string, context?: Record<string, unknown>): void {
    this.log(LogLevel.INFO, message, context);
  }

  /**
   * Log a warning message
   */
  warn(message: string, context?: Record<string, unknown>): void {
    this.log(LogLevel.WARN, message, context);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: Error, context?: Record<string, unknown>): void {
    this.log(LogLevel.ERROR, message, context, error);
  }

  /**
   * Log a fatal error message
   */
  fatal(message: string, error?: Error, context?: Record<string, unknown>): void {
    this.log(LogLevel.FATAL, message, context, error);
  }

  /**
   * Log with a custom level
   */
  logWithLevel(level: LogLevel, message: string, context?: Record<string, unknown>): void {
    this.log(level, message, context);
  }

  /**
   * Log only if severity meets minimum threshold
   */
  logIfSeverity(
    minSeverity: number,
    level: LogLevel,
    message: string,
    context?: Record<string, unknown>
  ): void {
    if (LogLevelSeverity[level] >= minSeverity) {
      this.log(level, message, context);
    }
  }

  /**
   * Measure and log execution time with appropriate log level based on duration
   */
  async measureExecution<T>(
    label: string,
    fn: () => Promise<T>,
    thresholds?: { warn?: number; error?: number }
  ): Promise<T> {
    const start = Date.now();
    try {
      const result = await fn();
      const duration = Date.now() - start;

      // Choose log level based on duration thresholds
      let level = LogLevel.DEBUG;
      if (thresholds?.error && duration > thresholds.error) {
        level = LogLevel.ERROR;
      } else if (thresholds?.warn && duration > thresholds.warn) {
        level = LogLevel.WARN;
      } else {
        level = LogLevel.INFO;
      }

      this.log(level, `${label} completed`, { duration: `${duration}ms` });
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      this.log(
        LogLevel.ERROR,
        `${label} failed`,
        { duration: `${duration}ms` },
        error instanceof Error ? error : new Error(String(error))
      );
      throw error;
    }
  }

  /**
   * Internal log method
   */
  private log(
    level: LogLevel,
    message: string,
    context?: Record<string, unknown>,
    error?: Error
  ): void {
    // Check if this level should be logged (using severity for better performance)
    if (!this.shouldLogLevel(level)) {
      return;
    }

    // Create log entry
    const entry: LogEntry = createLogEntry(level, message, {
      source: this.config.source,
      context,
      error,
    });

    // Format and output
    const formatted = formatLog(entry, this.formatOptions);
    console.log(formatted);
  }

  /**
   * Check if a level should be logged using severity comparison
   */
  private shouldLogLevel(level: LogLevel): boolean {
    return LogLevelSeverity[level] >= LogLevelSeverity[this.config.level];
  }

  /**
   * Check if a level is more severe than another
   */
  isMoreSevere(level: LogLevel, compareWith: LogLevel): boolean {
    return LogLevelSeverity[level] > LogLevelSeverity[compareWith];
  }

  /**
   * Get severity difference between two levels
   */
  getSeverityDiff(level1: LogLevel, level2: LogLevel): number {
    return LogLevelSeverity[level1] - LogLevelSeverity[level2];
  }

  /**
   * Get the numeric severity of the current log level
   */
  getCurrentSeverity(): number {
    return LogLevelSeverity[this.config.level];
  }

  /**
   * Get the numeric severity of a log level
   */
  getSeverity(level: LogLevel): number {
    return LogLevelSeverity[level];
  }

  /**
   * Update logger configuration
   */
  setLevel(level: LogLevel): void {
    this.config.level = level;
  }

  /**
   * Set level by severity (0-4)
   */
  setLevelBySeverity(severity: number): void {
    const levels = Object.entries(LogLevelSeverity)
      .find(([_, sev]) => sev === severity);
    if (levels) {
      this.config.level = levels[0] as LogLevel;
    }
  }

  /**
   * Update colors setting
   */
  setColors(enabled: boolean): void {
    this.config.colors = enabled;
    this.formatOptions.colors = enabled;
  }

  /**
   * Update format
   */
  setFormat(format: EngineLogFormat): void {
    this.config.format = format;
    this.formatOptions.format = format;
  }

  /**
   * Update timestamp setting
   */
  setTimestamp(enabled: boolean): void {
    this.config.timestamp = enabled;
    this.formatOptions.timestamp = enabled;
  }

  /**
   * Update timestamp format
   * 
   * @param _format - 'time' | 'datetime' | 'full' (reserved for future use)
   */
  setTimestampFormat(_format: 'time' | 'datetime' | 'full'): void {
    // Timestamp format is handled by ecosystem-core formatTimestamp function
    // This method is kept for API compatibility but doesn't modify formatOptions
  }

  /**
   * Format a timestamp using engine's timestamp formatter
   * Useful for consistent timestamp formatting across the system
   * 
   * @param date - Date to format (defaults to current time)
   * @param format - Format type ('time', 'datetime', or 'full')
   * @returns Formatted timestamp string
   */
  formatTimestamp(
    date?: Date,
    format: 'time' | 'datetime' | 'full' = 'time'
  ): string {
    return formatTimestamp(date || new Date(), format);
  }

  /**
   * Check if a level will be logged (uses shouldLog from ecosystem-core)
   */
  willLog(level: LogLevel): boolean {
    return shouldLog(level, this.config.level);
  }

  /**
   * Get current configuration
   */
  getConfig(): Readonly<EngineLoggerConfig> {
    return { ...this.config };
  }

  /**
   * Check if debug logging is enabled
   */
  isDebugEnabled(): boolean {
    return this.willLog(LogLevel.DEBUG);
  }

  /**
   * Check if info logging is enabled
   */
  isInfoEnabled(): boolean {
    return this.willLog(LogLevel.INFO);
  }

  /**
   * Check if warn logging is enabled
   */
  isWarnEnabled(): boolean {
    return this.willLog(LogLevel.WARN);
  }

  /**
   * Check if error logging is enabled
   */
  isErrorEnabled(): boolean {
    return this.willLog(LogLevel.ERROR);
  }
}

/**
 * Create a logger instance from engine config
 */
export function createEngineLogger(
  logLevel: 'debug' | 'info' | 'warn' | 'error' | 'silent',
  verbose: boolean = false
): EngineLogger | null {
  // Silent mode - no logger
  if (logLevel === 'silent') {
    return null;
  }

  // Map engine log level to ecosystem LogLevel
  const levelMap: Record<string, LogLevel> = {
    debug: LogLevel.DEBUG,
    info: LogLevel.INFO,
    warn: LogLevel.WARN,
    error: LogLevel.ERROR,
    fatal: LogLevel.FATAL,
  };

  const level = levelMap[logLevel] || LogLevel.INFO;

  return new EngineLogger({
    level,
    format: verbose ? 'pretty' : 'text',
    colors: true,
    timestamp: true, // Enable human-readable timestamps
    source: 'Orbyt',
  });
}
