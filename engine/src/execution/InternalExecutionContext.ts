/**
 * Internal Execution Context
 * 
 * These fields are NEVER user-controlled.
 * Engine injects them automatically at runtime.
 * 
 * Security: User workflow YAML cannot override these values.
 */

import type { TierLimits } from './ExecutionLimits.js';
import { getLimitsForTier } from './ExecutionLimits.js';

/**
 * Execution Identity (Engine-Generated)
 * Generated for each workflow execution
 */
export interface ExecutionIdentity {
  /** Unique execution ID (generated by engine) */
  executionId: string;
  
  /** Run ID for this workflow execution */
  runId: string;
  
  /** Trace ID for distributed tracing */
  traceId: string;
  
  /** Parent run ID if this is a nested workflow */
  parentRunId?: string;
  
  /** Execution start timestamp */
  startedAt: Date;
  
  /** Engine version that executed this workflow */
  engineVersion: string;
  
  /** Node ID for future distributed execution */
  nodeId?: string;
}

/**
 * Ownership Context (From Bridge/API)
 * Passed from website/bridge to engine
 */
export interface OwnershipContext {
  /** User ID who triggered execution */
  userId: string;
  
  /** Workspace/organization ID */
  workspaceId: string;
  
  /** Subscription ID */
  subscriptionId: string;
  
  /** Subscription tier (free, pro, enterprise) */
  subscriptionTier: string;
  
  /** Geographic region */
  region: string;
  
  /** Pricing model (ecosystem | component) */
  pricingModel: 'ecosystem' | 'component';
  
  /** Billing mode  */
  billingMode: 'ecosystem' | 'component';
}

/**
 * Billing Snapshot (Frozen at Execution Start)
 * Prevents billing disputes when pricing changes
 */
export interface BillingSnapshot {
  /** Base cost per automation execution */
  baseExecutionCost: number;
  
  /** Base cost per step */
  baseStepCost: number;
  
  /** Pricing tier at execution time */
  pricingTier: string;
  
  /** Discount applied (%) */
  discountApplied: number;
  
  /** Promo code applied */
  promoApplied?: string;
  
  /** Effective rate after discounts */
  effectiveRate: number;
  
  /** Billing snapshot version (for audit) */
  snapshotVersion: string;
  
  /** Timestamp when snapshot was taken */
  snapshotAt: Date;
}

/**
 * Usage Counters (Engine-Calculated)
 * Never user-editable
 */
export interface UsageCounters {
  /** Number of automations executed (always 1 per workflow) */
  automationCount: number;
  
  /** Total number of steps executed */
  stepCount: number;
  
  /** Weighted step count (sum of step weights) */
  weightedStepCount: number;
  
  /** Execution duration in seconds */
  durationSeconds: number;
  
  /** CPU usage (future) */
  resourceUsageCpu?: number;
  
  /** Memory usage (future) */
  resourceUsageMemory?: number;
}

/**
 * Derived Billing Context (Engine-Computed)
 * Calculated based on ownership + snapshot
 */
export interface DerivedBillingContext {
  /** Is this execution billable */
  isBillable: boolean;
  
  /** Billing scope resolved */
  billingScopeResolved: 'workflow' | 'step' | 'both';
  
  /** Effective product billing to */
  effectiveProduct: string;
  
  /** Pricing tier resolved from subscription */
  pricingTierResolved: string;
  
  /** Final cost calculated */
  totalCost: number;
}

/**
 * Security Metadata (Engine-Controlled)
 * Security boundaries and permissions
 */
export interface SecurityMetadata {
  /** Payment status (affects execution) */
  paymentStatus: 'active' | 'past_due' | 'canceled' | 'trial';
  
  /** Request source IP (optional) */
  ipAddress?: string;
  
  /** Security policy version */
  securityPolicyVersion?: string;
  
  /** Execution isolation level */
  isolationLevel: 'process' | 'container' | 'vm';
  
  /** Permissions granted for this execution */
  permissionsGranted: string[];
}

/**
 * Runtime State (Engine-Managed)
 * Current execution state
 */
export interface RuntimeState {
  /** Current workflow state */
  workflowState: 'pending' | 'running' | 'completed' | 'failed' | 'timeout' | 'cancelled';
  
  /** Actual retry count (not user-defined max) */
  retryCountActual: number;
  
  /** Was timeout triggered? */
  timeoutTriggered: boolean;
  
  /** Execution graph (resolved dependencies) */
  executionGraph?: Record<string, string[]>;
  
  /** Steps state map */
  stepsState: Record<string, 'pending' | 'running' | 'completed' | 'failed' | 'skipped'>;
}

/**
 * Request Context (Origin Information)
 * Where the execution request came from
 */
export interface RequestContext {
  /** Request origin */
  origin: 'cli' | 'api' | 'sdk' | 'webhook' | 'scheduler';
  
  /** Execution mode */
  mode: 'local' | 'server' | 'embedded' | 'dry-run';
  
  /** Who/what triggered this */
  triggeredBy?: string;
}

/**
 * Internal Execution Context (Complete)
 * This is what engine maintains internally. NEVER exposed to workflow.
 */
export interface InternalExecutionContext {
  /** Execution identity */
  _identity: ExecutionIdentity;
  
  /** Ownership from bridge */
  _ownership: OwnershipContext;
  
  /** Billing snapshot (frozen) */
  _billingSnapshot: BillingSnapshot;
  
  /** Usage counters */
  _usage: UsageCounters;
  
  /** Derived billing context */
  _billing: DerivedBillingContext;
  
  /** Tier-based execution limits (ENFORCED by engine) */
  _limits: TierLimits;
  
  /** Security metadata */
  _security: SecurityMetadata;
  
  /** Runtime state */
  _runtime: RuntimeState;
  
  /** Request context */
  _request: RequestContext;
  
  /** Audit metadata */
  _audit: {
    engineVersion: string;
    billingSnapshotVersion: string;
    executionVersion: string;
  };
}

/**
 * Step-level Internal Context
 * Injected into each step execution
 */
export interface InternalStepContext {
  /** Step usage (engine-calculated from user weight or default) */
  usage: {
    billable: boolean;
    unit: string;
    weight: number;
    computedCost: number;
  };
  
  /** Step requirements (engine-validated) */
  requires: {
    capabilities: string[];
    validated: boolean;
  };
  
  /** Execution hints (engine-optimized) */
  hints: {
    cacheable: boolean;
    idempotent: boolean;
    heavy: boolean;
    cost: 'free' | 'low' | 'medium' | 'high';
  };
}

/**
 * Context Builder
 * Used by engine to create internal context
 */
export class InternalContextBuilder {
  /**
   * Create execution identity
   */
  static createIdentity(engineVersion: string): ExecutionIdentity {
    return {
      executionId: this.generateId('exec'),
      runId: this.generateId('run'),
      traceId: this.generateId('trace'),
      startedAt: new Date(),
      engineVersion,
    };
  }
  
  /**
   * Create default ownership context (local mode)
   */
  static createDefaultOwnership(): OwnershipContext {
    return {
      userId: 'local',
      workspaceId: 'local',
      subscriptionId: 'local',
      subscriptionTier: 'free',
      region: 'local',
      pricingModel: 'ecosystem',
      billingMode: 'ecosystem',
    };
  }
  
  /**
   * Create billing snapshot
   */
  static createBillingSnapshot(
    subscriptionTier: string,
    billingMode: 'ecosystem' | 'component'
  ): BillingSnapshot {
    // Default pricing (override from bridge in production)
    // Billing mode affects pricing calculation (future implementation)
    const isEcosystemBilling = billingMode === 'ecosystem';
    
    return {
      baseExecutionCost: isEcosystemBilling ? 0 : 0, // Future: different rates
      baseStepCost: 0,
      pricingTier: subscriptionTier,
      discountApplied: 0,
      effectiveRate: 0,
      snapshotVersion: '1.0.0',
      snapshotAt: new Date(),
    };
  }
  
  /**
   * Initialize usage counters
   */
  static initializeCounters(): UsageCounters {
    return {
      automationCount: 1,
      stepCount: 0,
      weightedStepCount: 0,
      durationSeconds: 0,
    };
  }
  
  /**
   * Create derived billing context
   */
  static createDerivedBilling(
    ownership: OwnershipContext,
    snapshot: BillingSnapshot
  ): DerivedBillingContext {
    return {
      isBillable: ownership.subscriptionTier !== 'free',
      billingScopeResolved: 'both',
      effectiveProduct: 'orbyt',
      pricingTierResolved: snapshot.pricingTier,
      totalCost: 0,
    };
  }
  
  /**
   * Build complete internal context
   */
  static build(
    engineVersion: string,
    ownershipContext?: Partial<OwnershipContext>,
    requestOrigin: 'cli' | 'api' | 'sdk' | 'webhook' | 'scheduler' = 'cli',
    executionMode: 'local' | 'server' | 'embedded' | 'dry-run' = 'local'
  ): InternalExecutionContext {
    const identity = this.createIdentity(engineVersion);
    const ownership = {
      ...this.createDefaultOwnership(),
      ...ownershipContext,
    };
    const billingSnapshot = this.createBillingSnapshot(
      ownership.subscriptionTier,
      ownership.billingMode
    );
    const usage = this.initializeCounters();
    const billing = this.createDerivedBilling(ownership, billingSnapshot);
    const security = this.createSecurityMetadata(ownership);
    const runtime = this.initializeRuntimeState();
    const request = this.createRequestContext(requestOrigin, executionMode);
    
    return {
      _identity: identity,
      _ownership: ownership,
      _billingSnapshot: billingSnapshot,
      _usage: usage,
      _billing: billing,
      _limits: getLimitsForTier(ownership.subscriptionTier),
      _security: security,
      _runtime: runtime,
      _request: request,
      _audit: {
        engineVersion,
        billingSnapshotVersion: billingSnapshot.snapshotVersion,
        executionVersion: '1.0.0',
      },
    };
  }
  
  /**
   * Create security metadata
   */
  static createSecurityMetadata(ownership: OwnershipContext): SecurityMetadata {
    return {
      paymentStatus: ownership.subscriptionTier === 'free' ? 'trial' : 'active',
      isolationLevel: 'process',
      permissionsGranted: ['execute', 'read'],
    };
  }
  
  /**
   * Initialize runtime state
   */
  static initializeRuntimeState(): RuntimeState {
    return {
      workflowState: 'pending',
      retryCountActual: 0,
      timeoutTriggered: false,
      stepsState: {},
    };
  }
  
  /**
   * Create request context
   */
  static createRequestContext(
    origin: 'cli' | 'api' | 'sdk' | 'webhook' | 'scheduler',
    mode: 'local' | 'server' | 'embedded' | 'dry-run'
  ): RequestContext {
    return {
      origin,
      mode,
    };
  }
  
  /**
   * Create step internal context
   */
  static createStepContext(
    userWeight?: number,
    userUnit?: string
  ): InternalStepContext {
    return {
      usage: {
        billable: true,
        unit: userUnit || 'execution',
        weight: userWeight || 1,
        computedCost: 0, // Calculated later
      },
      requires: {
        capabilities: [],
        validated: false,
      },
      hints: {
        cacheable: false,
        idempotent: false,
        heavy: false,
        cost: 'low',
      },
    };
  }
  
  /**
   * Generate unique ID
   */
  private static generateId(prefix: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 15);
    return `${prefix}_${timestamp}_${random}`;
  }
}
