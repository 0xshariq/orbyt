/**
 * CLI Logger
 * 
 * Wraps EngineLogger from @orbytautomation/engine for CLI-specific use.
 * Timestamps are generated by the engine, ensuring consistency across
 * CLI, API, web dashboards, and other integrations.
 * 
 * Features inherited from EngineLogger:
 * - Severity-based log level filtering using LogLevelSeverity
 * - Multiple output formats (pretty, text, json, structured)
 * - Color support with ANSI codes
 * - Engine-generated timestamps (consistent across all platforms)
 * - Context and error tracking
 * - Performance measurement with automatic severity adjustment
 * 
 * @module utils
 */

import {
  EngineLogger,
  type EngineLoggerConfig,
  type EngineLogFormat,
} from '@orbytautomation/engine';
import { LogLevel } from '@dev-ecosystem/core';

/**
 * CLI log format type (re-exported from engine)
 */
export type CliLogFormat = EngineLogFormat;

/**
 * CLI log context (key-value pairs)
 */
export type CliLogContext = Record<string, unknown>;

/**
 * CLI Logger configuration (extends engine logger config)
 */
export interface CliLoggerConfig extends EngineLoggerConfig {
  /** CLI-specific context (merged with log context) */
  context?: CliLogContext;
}

/**
 * Singleton EngineLogger instance
 * 
 * All CLI loggers use this single EngineLogger instance under the hood.
 * This ensures consistent logging behavior across all formatters and commands.
 */
let engineLoggerInstance: EngineLogger | null = null;

/**
 * Get or create the singleton EngineLogger instance
 */
function getEngineLogger(config?: Partial<EngineLoggerConfig>): EngineLogger {
  if (!engineLoggerInstance) {
    // Create new instance with config
    engineLoggerInstance = new EngineLogger({
      level: config?.level ?? LogLevel.INFO,
      format: config?.format ?? 'pretty',
      colors: config?.colors ?? true,
      timestamp: config?.timestamp ?? true, // Engine generates timestamps
      source: config?.source ?? 'CLI',
    });
  } else if (config) {
    // Update existing logger config if provided
    engineLoggerInstance.setLevel(config.level ?? LogLevel.INFO);
    if (config.colors !== undefined) {
      engineLoggerInstance.setColors(config.colors);
    }
    if (config.format !== undefined) {
      engineLoggerInstance.setFormat(config.format);
    }
    if (config.timestamp !== undefined) {
      engineLoggerInstance.setTimestamp(config.timestamp);
    }
  }
  return engineLoggerInstance;
}

/**
 * Reset the EngineLogger instance (useful for testing)
 */
export function resetEngineLogger(): void {
  engineLoggerInstance = null;
}

/**
 * CLI Logger class
 * 
 * Wraps the singleton EngineLogger for CLI-specific use.
 * All logging functionality and timestamps come from EngineLogger.
 * This ensures consistency across CLI, API, web dashboards, etc.
 */
export class CliLogger {
  private engineLogger: EngineLogger;
  private cliContext: CliLogContext;

  constructor(config: Partial<CliLoggerConfig> = {}) {
    // Use singleton EngineLogger instance
    this.engineLogger = getEngineLogger({
      level: config.level ?? LogLevel.INFO,
      format: config.format ?? 'pretty',
      colors: config.colors ?? true,
      timestamp: config.timestamp ?? true, // Engine generates timestamps
      source: config.source ?? 'CLI',
    });

    this.cliContext = config.context ?? {};
  }

  /**
   * Get the underlying EngineLogger instance
   */
  getEngineLogger(): EngineLogger {
    return this.engineLogger;
  }

  /**
   * Get CLI-specific context
   */
  getCliContext(): Readonly<CliLogContext> {
    return { ...this.cliContext };
  }

  /**
   * Set CLI-specific context that will be merged with all logs
   */
  setCliContext(context: CliLogContext): void {
    this.cliContext = context;
  }

  /**
   * Merge additional context into existing CLI context
   */
  addCliContext(context: CliLogContext): void {
    this.cliContext = { ...this.cliContext, ...context };
  }

  /**
   * Set log level
   */
  setLevel(level: LogLevel): void {
    this.engineLogger.setLevel(level);
  }

  /**
   * Get current log level
   */
  getLevel(): LogLevel {
    return this.engineLogger.getConfig().level;
  }

  /**
   * Set colors enabled/disabled
   */
  setColors(enabled: boolean): void {
    this.engineLogger.setColors(enabled);
  }

  /**
   * Check if a log level is enabled
   */
  isLevelEnabled(level: LogLevel): boolean {
    return this.engineLogger.willLog(level);
  }

  /**
   * Convenience methods for checking specific levels
   */
  isDebugEnabled(): boolean {
    return this.engineLogger.isDebugEnabled();
  }

  isInfoEnabled(): boolean {
    return this.engineLogger.isInfoEnabled();
  }

  isWarnEnabled(): boolean {
    return this.engineLogger.isWarnEnabled();
  }

  isErrorEnabled(): boolean {
    return this.engineLogger.isErrorEnabled();
  }

  isFatalEnabled(): boolean {
    // Fatal is higher severity than error, so if error is enabled, fatal is too
    return this.engineLogger.willLog(LogLevel.FATAL);
  }

  /**
   * Log methods - delegate to EngineLogger with merged CLI context
   * All timestamp handling is done by EngineLogger
   */
  debug(message: string, context?: Record<string, unknown>): void {
    this.engineLogger.debug(message, { ...this.cliContext, ...context });
  }

  info(message: string, context?: Record<string, unknown>): void {
    this.engineLogger.info(message, { ...this.cliContext, ...context });
  }

  warn(message: string, context?: Record<string, unknown>): void {
    this.engineLogger.warn(message, { ...this.cliContext, ...context });
  }

  error(message: string, error?: Error, context?: Record<string, unknown>): void {
    this.engineLogger.error(message, error, { ...this.cliContext, ...context });
  }

  fatal(message: string, error?: Error, context?: Record<string, unknown>): void {
    this.engineLogger.fatal(message, error, { ...this.cliContext, ...context });
  }

  /**
   * Measure execution time with automatic severity-based logging
   */
  async measureExecution<T>(
    label: string,
    fn: () => Promise<T>,
    thresholds?: { warn?: number; error?: number }
  ): Promise<T> {
    return this.engineLogger.measureExecution(label, fn, thresholds);
  }
}

/**
 * Create a CLI logger instance
 * 
 * Factory function for creating CLI loggers with engine-generated timestamps.
 */
export function createCliLogger(config?: Partial<CliLoggerConfig>): CliLogger {
    return new CliLogger(config);
}

/**
 * Default logger instance for CLI (singleton pattern)
 */
let defaultLogger: CliLogger | null = null;

/**
 * Get or create the default CLI logger
 */
export function getCliLogger(): CliLogger {
    if (!defaultLogger) {
        defaultLogger = createCliLogger();
    }
    return defaultLogger;
}

/**
 * Set the default CLI logger
 */
export function setDefaultCliLogger(logger: CliLogger): void {
    defaultLogger = logger;
}

// ==================== JSON Formatting Helpers for JSONFormatter ====================

/**
 * Format CLI event as JSON string
 * 
 * Used by JsonFormatter to output events in NDJSON format.
 * Each event is a single line of JSON output.
 */
export function formatJsonEvent(event: unknown, verbose = false): string {
    const eventObj = event && typeof event === 'object' ? event as Record<string, unknown> : {};
    const jsonEvent = {
        ...eventObj,
        timestamp: event && typeof event === 'object' && 'timestamp' in event
            ? (event as any).timestamp.toISOString()
            : new Date().toISOString(),
    };

    return verbose
        ? JSON.stringify(jsonEvent, null, 2)
        : JSON.stringify(jsonEvent);
}

/**
 * Format workflow result as JSON string
 * 
 * Used by JsonFormatter to output final workflow result.
 */
export function formatJsonResult(result: unknown, verbose = false): string {
    // Convert Map stepResults to plain object for JSON serialization
    if (result && typeof result === 'object' && 'stepResults' in result) {
        const resultObj = result as any;
        const stepResultsArray: Array<[string, any]> = [];

        if (resultObj.stepResults instanceof Map) {
            for (const [key, value] of resultObj.stepResults.entries()) {
                stepResultsArray.push([key, value]);
            }
        }

        const jsonResult = {
            ...resultObj,
            stepResults: Object.fromEntries(stepResultsArray),
            error: resultObj.error ? {
                message: resultObj.error.message,
                name: resultObj.error.name,
                stack: verbose ? resultObj.error.stack : undefined,
            } : undefined,
        };

        return verbose
            ? JSON.stringify(jsonResult, null, 2)
            : JSON.stringify(jsonResult);
    }

    return verbose
        ? JSON.stringify(result, null, 2)
        : JSON.stringify(result);
}

/**
 * Format error as JSON string
 * 
 * Used by JsonFormatter to output errors in structured format.
 */
export function formatJsonError(error: Error): string {
    const jsonError = {
        type: 'error',
        timestamp: new Date().toISOString(),
        error: {
            message: error.message,
            name: error.name,
            stack: error.stack,
        },
    };

    return JSON.stringify(jsonError, null, 2);
}
