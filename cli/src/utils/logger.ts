/**
 * CLI Logger
 * 
 * Wraps EngineLogger from @orbytautomation/engine for CLI-specific use.
 * Timestamps are generated by the engine, ensuring consistency across
 * CLI, API, web dashboards, and other integrations.
 * 
 * Features inherited from EngineLogger:
 * - Severity-based log level filtering using LogLevelSeverity
 * - Multiple output formats (pretty, text, json, structured)
 * - Color support with ANSI codes
 * - Engine-generated timestamps (consistent across all platforms)
 * - Context and error tracking
 * - Performance measurement with automatic severity adjustment
 * 
 * @module utils
 */

import {
  LoggerManager,
  type EngineLoggerConfig,
  type EngineLogFormat,
} from '@orbytautomation/engine';
import { LogLevel } from '@dev-ecosystem/core';

/**
 * CLI log format type (re-exported from engine)
 */
export type CliLogFormat = EngineLogFormat;

/**
 * CLI log context (key-value pairs)
 */
export type CliLogContext = Record<string, unknown>;

/**
 * CLI Logger configuration (extends engine logger config)
 * Only context is CLI-specific, all other options are passed to the constructor as overrides.
 */
export interface CliLoggerConfig extends EngineLoggerConfig {
  /** CLI-specific context (merged with log context) */
  context?: CliLogContext;
}

/**
 * Get the LoggerManager singleton instance
 * Use this for all logging and log access in CLI and formatters.
 */
export function getLoggerManager() {
  return LoggerManager;
}

/**
 * Get the EngineLogger instance from LoggerManager
 */
export function getEngineLogger() {
  return LoggerManager.getLogger();
}

/**
 * Reset the LoggerManager instance (useful for testing)
 */
export function resetLoggerManager(): void {
  LoggerManager.reset();
}
/**
 * Filter logs by log level (debug, info, warn, error, fatal)
 */
export function filterLogsByLevel(logs: any[], level: LogLevel): any[] {
  return logs.filter(log => log.level === level);
}

/**
 * Filter logs by log type (e.g., WORKFLOW_STARTED, STEP_FAILED, etc.)
 */
export function filterLogsByType(logs: any[], type: string): any[] {
  return logs.filter(log => log.type === type);
}

/**
 * Group logs by log level
 */
export function groupLogsByLevel(logs: any[]): Record<LogLevel, any[]> {
  return logs.reduce((acc, log) => {
    (acc[log.level] = acc[log.level] || []).push(log);
    return acc;
  }, {} as Record<LogLevel, any[]>);
}

/**
 * Group logs by log type
 */
export function groupLogsByType(logs: any[]): Record<string, any[]> {
  return logs.reduce((acc, log) => {
    (acc[log.type] = acc[log.type] || []).push(log);
    return acc;
  }, {} as Record<string, any[]>);
}

/**
 * Print a summary of log counts by level and type
 */
export function printLogSummary(logs: any[]): void {
  const byLevel = groupLogsByLevel(logs);
  const byType = groupLogsByType(logs);
  // Print by level
  console.log('Log Events by Level:');
  Object.entries(byLevel).forEach(([level, arr]) => {
    console.log(`  ${level}: ${arr.length}`);
  });
  // Print by type
  console.log('Log Events by Type:');
  Object.entries(byType).forEach(([type, arr]) => {
    console.log(`  ${type}: ${arr.length}`);
  });
}

/**
 * Pretty print logs for CLI output (with color if enabled)
 */
export function prettyPrintLogs(logs: any[], verbose = false): void {
  logs.forEach(log => {
    // Use formatJsonEvent for now; can be improved for color/UX
    console.log(formatJsonEvent(log, verbose));
  });
}

/**
 * CLI Logger class
 * 
 * Wraps the singleton EngineLogger for CLI-specific use.
 * All logging functionality and timestamps come from EngineLogger.
 * This ensures consistency across CLI, API, web dashboards, etc.
 */
export class CliLogger {
  private cliContext: CliLogContext;

  constructor(config: Partial<CliLoggerConfig> = {}) {
    // Only context is CLI-specific, all other options are passed as overrides
    if ('level' in config && config.level !== undefined) {
      LoggerManager.getLogger().setLevel(config.level);
    }
    if ('colors' in config && config.colors !== undefined) {
      LoggerManager.getLogger().setColors(config.colors);
    }
    if ('format' in config && config.format !== undefined) {
      LoggerManager.getLogger().setFormat(config.format);
    }
    if ('timestamp' in config && config.timestamp !== undefined) {
      LoggerManager.getLogger().setTimestamp(config.timestamp);
    }
    this.cliContext = config.context ?? {};
  }

  /**
   * Get the underlying EngineLogger instance (from LoggerManager)
   */
  getEngineLogger() {
    return LoggerManager.getLogger();
  }

  /**
   * Get CLI-specific context
   */
  getCliContext(): Readonly<CliLogContext> {
    return { ...this.cliContext };
  }

  /**
   * Set CLI-specific context that will be merged with all logs
   */
  setCliContext(context: CliLogContext): void {
    this.cliContext = context;
  }

  /**
   * Merge additional context into existing CLI context
   */
  addCliContext(context: CliLogContext): void {
    this.cliContext = { ...this.cliContext, ...context };
  }

  /**
   * Set log level
   */
  setLevel(level: LogLevel): void {
    LoggerManager.getLogger().setLevel(level);
  }

  /**
   * Get current log level
   */
  getLevel(): LogLevel {
    return LoggerManager.getLogger().getConfig().level;
  }

  /**
   * Set colors enabled/disabled
   */
  setColors(enabled: boolean): void {
    LoggerManager.getLogger().setColors(enabled);
  }

  /**
   * Check if a log level is enabled
   */
  isLevelEnabled(level: LogLevel): boolean {
    return LoggerManager.getLogger().willLog(level);
  }

  /**
   * Convenience methods for checking specific levels
   */
  isDebugEnabled(): boolean {
    return LoggerManager.getLogger().isDebugEnabled();
  }

  isInfoEnabled(): boolean {
    return LoggerManager.getLogger().isInfoEnabled();
  }

  isWarnEnabled(): boolean {
    return LoggerManager.getLogger().isWarnEnabled();
  }

  isErrorEnabled(): boolean {
    return LoggerManager.getLogger().isErrorEnabled();
  }

  isFatalEnabled(): boolean {
    // Fatal is higher severity than error, so if error is enabled, fatal is too
    return LoggerManager.getLogger().willLog(LogLevel.FATAL);
  }

  /**
   * Log methods - delegate to EngineLogger with merged CLI context
   * All timestamp handling is done by EngineLogger
   */
  debug(message: string, context?: Record<string, unknown>): void {
    LoggerManager.getLogger().debug(message, { ...this.cliContext, ...context });
  }

  info(message: string, context?: Record<string, unknown>): void {
    LoggerManager.getLogger().info(message, { ...this.cliContext, ...context });
  }

  warn(message: string, context?: Record<string, unknown>): void {
    LoggerManager.getLogger().warn(message, { ...this.cliContext, ...context });
  }

  error(message: string, error?: Error, context?: Record<string, unknown>): void {
    LoggerManager.getLogger().error(message, error, { ...this.cliContext, ...context });
  }

  fatal(message: string, error?: Error, context?: Record<string, unknown>): void {
    LoggerManager.getLogger().fatal(message, error, { ...this.cliContext, ...context });
  }

  /**
   * Measure execution time with automatic severity-based logging
   */
  async measureExecution<T>(
    label: string,
    fn: () => Promise<T>,
    thresholds?: { warn?: number; error?: number }
  ): Promise<T> {
    return LoggerManager.getLogger().measureExecution(label, fn, thresholds);
  }

  /**
   * Get all JSON logs from LoggerManager
   */
  getJsonLogs(): any[] {
    return LoggerManager.getJSONLogs();
  }

  /**
   * Get logs filtered by log level
   */
  getLogsByLevel(level: LogLevel): any[] {
    return this.getJsonLogs().filter(log => log.level === level);
  }

  /**
   * Get logs filtered by log type
   */
  getLogsByType(type: string): any[] {
    return this.getJsonLogs().filter(log => log.type === type);
  }

  /**
   * Format logs for CLI output by log level
   */
  formatLogsByLevel(level: LogLevel, verbose = false): string[] {
    return this.getLogsByLevel(level).map(log => formatJsonEvent(log, verbose));
  }

  /**
   * Format all logs for CLI output
   */
  formatAllLogs(verbose = false): string[] {
    return this.getJsonLogs().map(log => formatJsonEvent(log, verbose));
  }
  /**
   * Filter logs by log level (debug, info, warn, error, fatal)
   */
  filterLogsByLevel(level: LogLevel): any[] {
    return filterLogsByLevel(this.getJsonLogs(), level);
  }

  /**
   * Filter logs by log type (e.g., WORKFLOW_STARTED, STEP_FAILED, etc.)
   */
  filterLogsByType(type: string): any[] {
    return filterLogsByType(this.getJsonLogs(), type);
  }

  /**
   * Group logs by log level
   */
  groupLogsByLevel(): Record<LogLevel, any[]> {
    return groupLogsByLevel(this.getJsonLogs());
  }

  /**
   * Group logs by log type
   */
  groupLogsByType(): Record<string, any[]> {
    return groupLogsByType(this.getJsonLogs());
  }

  /**
   * Print a summary of log counts by level and type
   */
  printLogSummary(): void {
    printLogSummary(this.getJsonLogs());
  }

  /**
   * Pretty print logs for CLI output (with color if enabled)
   */
  prettyPrintLogs(verbose = false): void {
    prettyPrintLogs(this.getJsonLogs(), verbose);
  }
}

/**
 * Create a CLI logger instance
 * 
 * Factory function for creating CLI loggers with engine-generated timestamps.
 */
export function createCliLogger(config?: Partial<CliLoggerConfig>): CliLogger {
  return new CliLogger(config);
}

/**
 * Get the LoggerManager singleton for CLI and formatters
 */
export function getCliLoggerManager() {
  return LoggerManager;
}

// ==================== JSON Formatting Helpers for JSONFormatter ====================

/**
 * Get structured JSON logs from LoggerManager
 */
export function getCliJsonLogs() {
  return LoggerManager.getJSONLogs();
}

/**
 * Format CLI event as JSON string
 * 
 * Used by JsonFormatter to output events in NDJSON format.
 * Each event is a single line of JSON output.
 */
export function formatJsonEvent(event: unknown, verbose = false): string {
  const eventObj = event && typeof event === 'object' ? event as Record<string, unknown> : {};
  const jsonEvent = {
    ...eventObj,
    timestamp: event && typeof event === 'object' && 'timestamp' in event
      ? (event as any).timestamp.toISOString()
      : new Date().toISOString(),
  };

  return verbose
    ? JSON.stringify(jsonEvent, null, 2)
    : JSON.stringify(jsonEvent);
}

/**
 * Format workflow result as JSON string
 * 
 * Used by JsonFormatter to output final workflow result.
 */
export function formatJsonResult(result: unknown, verbose = false): string {
  // Convert Map stepResults to plain object for JSON serialization
  if (result && typeof result === 'object' && 'stepResults' in result) {
    const resultObj = result as any;
    const stepResultsArray: Array<[string, any]> = [];

    if (resultObj.stepResults instanceof Map) {
      for (const [key, value] of resultObj.stepResults.entries()) {
        stepResultsArray.push([key, value]);
      }
    }

    const jsonResult = {
      ...resultObj,
      stepResults: Object.fromEntries(stepResultsArray),
      error: resultObj.error ? {
        message: resultObj.error.message,
        name: resultObj.error.name,
        stack: verbose ? resultObj.error.stack : undefined,
      } : undefined,
    };

    return verbose
      ? JSON.stringify(jsonResult, null, 2)
      : JSON.stringify(jsonResult);
  }

  return verbose
    ? JSON.stringify(result, null, 2)
    : JSON.stringify(result);
}

/**
 * Format error as JSON string
 * 
 * Used by JsonFormatter to output errors in structured format.
 */
export function formatJsonError(error: Error): string {
  const jsonError = {
    type: 'error',
    timestamp: new Date().toISOString(),
    error: {
      message: error.message,
      name: error.name,
      stack: error.stack,
    },
  };

  return JSON.stringify(jsonError, null, 2);
}
